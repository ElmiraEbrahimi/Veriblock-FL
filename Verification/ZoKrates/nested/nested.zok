import "utils/casts/field_to_u32" as field_to_u32;
import "utils/casts/u32_to_field" as u32_to_field;
import "utils/casts/field_to_u64" as field_to_u64;
import "utils/casts/u64_to_field" as u64_to_field;

const field max = 0-1;
const field threshold = 20888242871839275222246405745257275088548364400416034343698204186575808495617;
const u32  fe = 9;
const u32  ac = 6;
const field ac_f=6;
const u32  bs = 10;

def add(field mut a, field mut b, field mut a_sign, field mut b_sign) -> (field, field) {
    field mut a_cleansed = if a_sign==0 { a } else { max-a+1};
    field mut b_cleansed = if b_sign==0  {b} else {max-b+1};
    field mut c = if a_sign == b_sign && a_sign == 1 {(max+1-a_cleansed-b_cleansed)} else {a+b};
    field mut c_sign = if c > threshold {1} else {0} ;
    return (c, c_sign);
}


def subtract(field mut a, field mut b, field mut a_sign, field mut b_sign) -> (field, field) {
    field mut a_cleansed = if a_sign==0 {a} else {max-a+1} ;
    field mut b_cleansed = if b_sign==0 {b} else {max-b+1} ;
    field mut c = if a_sign != b_sign && a_sign==0 {a_cleansed+b_cleansed} else {a-b} ;
    field mut d = if c > threshold {1} else {0} ;
    return (c, d);
}


def divide(field mut a, field mut b, field mut a_sign, field mut b_sign) -> (field, field) {
    field mut a_cleansed = if a_sign==0 {a} else {max-a+1};
    field mut b_cleansed = if b_sign==0 {b} else {max-b+1};
    // Convert to u64 for easier arithmetic
    u64 a_u64 =field_to_u64(a_cleansed);
    u64 b_u64 = field_to_u64(b_cleansed);
     // Compute the remainder
    u64 remainder = a_u64%b_u64;
    // Adjust the numerator to ensure it's divisible by the denominator
    a_cleansed = u64_to_field(a_u64-remainder);
    // Determine the result
    field mut res = a_cleansed/b_cleansed;
    // Determine the sign of the result
    field mut sign = if a_sign==b_sign || res==0 {0} else {1};
    res = if sign == 0 {res} else {max+1-res};
    return (res, sign);
}

def multiply(field mut a, field mut b, field mut a_sign, field mut b_sign) -> (field, field) {
    field mut a_cleansed = if a_sign==0 {a} else {max-a+1};
    field mut b_cleansed = if b_sign==0 {b} else {max-b+1};
    field mut res = a_cleansed*b_cleansed;
    field mut sign = if a_sign==b_sign || res==0 {0} else {1};
    res = if sign==0 {res} else {max-res+1};
    return (res, sign);
}

// Arithmetic operations: add, subtract, multiply, divide
// Assume these are defined as per your initial input

// Function to update global weights and biases
def update_global(field[ac][fe] global_w, field[ac][fe] local_w, field[ac] global_b, field[ac] local_b, field k) -> (field[ac][fe], field[ac]) {
    field[ac][fe] new_global_w;
    field[ac] new_global_b;
    
    // Update global weights using the provided logic
    for u32 i in 0..ac {
        for u32 j in 0..fe {
            // Compute the difference local_w[i][j] - global_w[i][j]
            (field diff, field diff_sign) = subtract(local_w[i][j], global_w[i][j], 0, 0);
            // Divide the difference by k
            (field update, field update_sign) = divide(diff, k, diff_sign, 0);
            // Add the update to the global_w[i][j]
            (new_global_w[i][j], ) = add(global_w[i][j], update, 0, update_sign);
        }
    }
    
    // Update global biases using the provided logic
    for u32 i in 0..ac {
        // Compute the difference local_b[i] - global_b[i]
        (field diff, field diff_sign) = subtract(local_b[i], global_b[i], 0, 0);
        // Divide the difference by k
        (field update, field update_sign) = divide(diff, k, diff_sign, 0);
        // Add the update to the global_b[i]
        (new_global_b[i], ) = add(global_b[i], update, 0, update_sign);
    }
    
    return (new_global_w, new_global_b);
}

// Main function with correctness check
def main(private field[ac][fe] local_w, private field[ac] local_b, public field[ac][fe] global_w, public field[ac] global_b, public field k, public field[ac][fe] expected_global_w, public field[ac] expected_global_b) -> (bool) {
    field[ac][fe] computed_global_w;
    field[ac] computed_global_b;
    bool is_correct = true;
    
    // Compute updated global weights and biases
    (computed_global_w, computed_global_b) = update_global(global_w, local_w, global_b, local_b, k);
    
    // Check if computed values match the expected values
    for u32 i in 0..ac {
        for u32 j in 0..fe {
            if computed_global_w[i][j] != expected_global_w[i][j] {
                is_correct = false;
            }
        }
        if computed_global_b[i] != expected_global_b[i] {
            is_correct = false;
        }
    }
    
    return is_correct;
}
